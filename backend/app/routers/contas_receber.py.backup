# app/routers/contas_receber.py
from typing import List, Optional
from datetime import date, timedelta
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from decimal import Decimal

from app.database import get_db
from app.models.user import User
from app.models.contas_receber import ContaReceber
from app.models.pessoa import Pessoa
from app.routers.auth import get_current_user
from app.schemas.contas_receber import (
    ContaReceberCreate,
    ContaReceberUpdate,
    ContaReceberResponse,
    ContaReceberBaixa,
    ContaReceberParcelamento,
    ContaReceberReparcelamento,
    ContaReceberCancelamento,
)

router = APIRouter(prefix="/contas-receber", tags=["Contas a Receber"])


def assert_same_tenant_conta(user: User, conta: ContaReceber):
    """Valida se o usuário pertence ao mesmo tenant da conta"""
    if user.issuper:
        return
    if user.codemp != conta.codemp or user.codfil != conta.codfil:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Acesso negado: conta pertence a outro tenant"
        )


async def get_conta_or_404(
    codcar: int,
    db: AsyncSession,
    current_user: User
) -> ContaReceber:
    """Busca conta a receber ou retorna 404"""
    query = select(ContaReceber).where(ContaReceber.codcar == codcar)
    
    # Se não for superadmin, filtra por tenant
    if not current_user.issuper:
        query = query.where(
            and_(
                ContaReceber.codemp == current_user.codemp,
                ContaReceber.codfil == current_user.codfil
            )
        )
    
    result = await db.execute(query)
    conta = result.scalar_one_or_none()
    
    if not conta:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conta a receber não encontrada"
        )
    
    return conta


# ========== CRUD ==========

@router.post("", response_model=ContaReceberResponse, status_code=status.HTTP_201_CREATED)
async def create_conta_receber(
    payload: ContaReceberCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Criar nova conta a receber"""
    
    # Valida se cliente existe e pertence ao tenant
    query_cliente = select(Pessoa).where(Pessoa.codpes == payload.codcli)
    if not current_user.issuper:
        query_cliente = query_cliente.where(
            and_(
                Pessoa.codemp == current_user.codemp,
                Pessoa.codfil == current_user.codfil
            )
        )
    
    result = await db.execute(query_cliente)
    cliente = result.scalar_one_or_none()
    
    if not cliente:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Cliente não encontrado ou não pertence ao seu tenant"
        )
    
    # Valida parcelas
    if payload.numpar > payload.totpar:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Número da parcela não pode ser maior que o total de parcelas"
        )
    
    # Cria conta
    nova_conta = ContaReceber(
        codcli=payload.codcli,
        vlrcar=payload.vlrcar,
        datven=payload.datven,
        datrec=payload.datrec,
        statcar=payload.statcar,
        catcar=payload.catcar,
        forrec=payload.forrec,
        numpar=payload.numpar,
        totpar=payload.totpar,
        obscar=payload.obscar,
        numdoc=payload.numdoc,
        codemp=current_user.codemp,
        codfil=current_user.codfil,
        usucri=current_user.codusu,
    )
    
    db.add(nova_conta)
    await db.commit()
    await db.refresh(nova_conta)
    
    return nova_conta


@router.get("", response_model=List[ContaReceberResponse])
async def list_contas_receber(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    codcli: Optional[int] = None,
    statcar: Optional[str] = None,
    catcar: Optional[str] = None,
    datven_inicio: Optional[date] = None,
    datven_fim: Optional[date] = None,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Listar contas a receber com filtros"""
    
    query = select(ContaReceber)
    
    # Filtro de tenant (superadmin vê tudo)
    if not current_user.issuper:
        query = query.where(
            and_(
                ContaReceber.codemp == current_user.codemp,
                ContaReceber.codfil == current_user.codfil
            )
        )
    
    # Filtros opcionais
    if codcli:
        query = query.where(ContaReceber.codcli == codcli)
    
    if statcar:
        query = query.where(ContaReceber.statcar == statcar)
    
    if catcar:
        query = query.where(ContaReceber.catcar == catcar)
    
    if datven_inicio:
        query = query.where(ContaReceber.datven >= datven_inicio)
    
    if datven_fim:
        query = query.where(ContaReceber.datven <= datven_fim)
    
    # Ordenação por vencimento
    query = query.order_by(ContaReceber.datven.desc())
    query = query.offset(skip).limit(limit)
    
    result = await db.execute(query)
    contas = result.scalars().all()
    
    return contas


@router.get("/{codcar}", response_model=ContaReceberResponse)
async def get_conta_receber(
    codcar: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Obter uma conta a receber específica"""
    conta = await get_conta_or_404(codcar, db, current_user)
    return conta


@router.patch("/{codcar}", response_model=ContaReceberResponse)
async def update_conta_receber(
    codcar: int,
    payload: ContaReceberUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Atualizar conta a receber"""
    conta = await get_conta_or_404(codcar, db, current_user)
    
    # Valida se conta não está recebida ou cancelada
    if conta.statcar in ["RECEBIDO", "CANCELADO"]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Não é possível editar conta com status {conta.statcar}"
        )
    
    # Atualiza campos
    update_data = payload.model_dump(exclude_unset=True)
    
    for field, value in update_data.items():
        setattr(conta, field, value)
    
    conta.usualt = current_user.codusu
    
    await db.commit()
    await db.refresh(conta)
    
    return conta


@router.delete("/{codcar}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_conta_receber(
    codcar: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Deletar conta a receber"""
    conta = await get_conta_or_404(codcar, db, current_user)
    
    # Valida se conta não está recebida
    if conta.statcar == "RECEBIDO":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Não é possível deletar conta já recebida. Cancele-a se necessário."
        )
    
    await db.delete(conta)
    await db.commit()
    
    return None


# ========== BAIXA DE TÍTULOS ==========

@router.post("/{codcar}/baixar", response_model=ContaReceberResponse)
async def baixar_conta_receber(
    codcar: int,
    payload: ContaReceberBaixa,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Dar baixa em conta a receber (marcar como recebido)"""
    conta = await get_conta_or_404(codcar, db, current_user)
    
    # Valida status
    if conta.statcar == "RECEBIDO":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Conta já está recebida"
        )
    
    if conta.statcar == "CANCELADO":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Não é possível dar baixa em conta cancelada"
        )
    
    # Atualiza conta
    conta.statcar = "RECEBIDO"
    conta.datrec = payload.datrec
    
    if payload.forrec:
        conta.forrec = payload.forrec
    
    if payload.obscar:
        obs_anterior = conta.obscar or ""
        conta.obscar = f"{obs_anterior}\n[BAIXA] {payload.obscar}".strip()
    
    conta.usualt = current_user.codusu
    
    await db.commit()
    await db.refresh(conta)
    
    return conta


# ========== PARCELAMENTO ==========

@router.post("/parcelar", response_model=List[ContaReceberResponse])
async def parcelar_conta_receber(
    payload: ContaReceberParcelamento,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Criar conta parcelada (gera múltiplas contas)"""
    
    if payload.totpar < 2:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Parcelamento requer no mínimo 2 parcelas"
        )
    
    # Calcula valor de cada parcela
    vlr_parcela = payload.vlrcar / payload.totpar
    
    contas_criadas = []
    
    for num_parcela in range(1, payload.totpar + 1):
        # Calcula data de vencimento da parcela
        dias_adicionar = (num_parcela - 1) * payload.intervalo_dias
        datven_parcela = payload.datven_primeira + timedelta(days=dias_adicionar)
        
        # Cria a parcela
        nova_conta = ContaReceber(
            codcli=0,  # Deve ser informado via payload
            vlrcar=vlr_parcela,
            datven=datven_parcela,
            statcar="A_RECEBER",
            catcar=payload.catcar,
            forrec=payload.forrec,
            numpar=num_parcela,
            totpar=payload.totpar,
            obscar=payload.obscar,
            numdoc=payload.numdoc,
            codemp=current_user.codemp,
            codfil=current_user.codfil,
            usucri=current_user.codusu,
        )
        
        db.add(nova_conta)
        contas_criadas.append(nova_conta)
    
    await db.commit()
    
    # Refresh todas as contas
    for conta in contas_criadas:
        await db.refresh(conta)
    
    return contas_criadas


@router.post("/{codcar}/reparcelar", response_model=List[ContaReceberResponse])
async def reparcelar_conta_receber(
    codcar: int,
    payload: ContaReceberReparcelamento,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Reparcelar conta existente"""
    conta_original = await get_conta_or_404(codcar, db, current_user)
    
    # Valida status
    if conta_original.statcar in ["RECEBIDO", "CANCELADO"]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Não é possível reparcelar conta com status {conta_original.statcar}"
        )
    
    if payload.totpar_novo < 2:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Reparcelamento requer no mínimo 2 parcelas"
        )
    
    # Cancela conta original
    conta_original.statcar = "CANCELADO"
    conta_original.obscar = f"{conta_original.obscar or ''}\n[REPARCELADO]".strip()
    conta_original.usualt = current_user.codusu
    
    # Calcula valor de cada nova parcela
    vlr_parcela = conta_original.vlrcar / payload.totpar_novo
    
    contas_criadas = []
    
    for num_parcela in range(1, payload.totpar_novo + 1):
        # Calcula data de vencimento da parcela
        dias_adicionar = (num_parcela - 1) * payload.intervalo_dias
        datven_parcela = payload.datven_primeira + timedelta(days=dias_adicionar)
        
        # Cria a nova parcela
        nova_conta = ContaReceber(
            codcli=conta_original.codcli,
            vlrcar=vlr_parcela,
            datven=datven_parcela,
            statcar="A_RECEBER",
            catcar=conta_original.catcar,
            forrec=conta_original.forrec,
            numpar=num_parcela,
            totpar=payload.totpar_novo,
            obscar=f"Reparcelamento de #{codcar}. {payload.obscar or ''}".strip(),
            numdoc=conta_original.numdoc,
            codemp=current_user.codemp,
            codfil=current_user.codfil,
            usucri=current_user.codusu,
        )
        
        db.add(nova_conta)
        contas_criadas.append(nova_conta)
    
    await db.commit()
    
    # Refresh todas as contas
    for conta in contas_criadas:
        await db.refresh(conta)
    
    return contas_criadas


# ========== CANCELAMENTO ==========

@router.post("/{codcar}/cancelar", response_model=ContaReceberResponse)
async def cancelar_conta_receber(
    codcar: int,
    payload: ContaReceberCancelamento,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Cancelar conta a receber"""
    conta = await get_conta_or_404(codcar, db, current_user)
    
    # Valida status
    if conta.statcar == "RECEBIDO":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Não é possível cancelar conta já recebida"
        )
    
    if conta.statcar == "CANCELADO":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Conta já está cancelada"
        )
    
    # Cancela conta
    conta.statcar = "CANCELADO"
    obs_anterior = conta.obscar or ""
    conta.obscar = f"{obs_anterior}\n[CANCELADO] {payload.motivo}".strip()
    conta.usualt = current_user.codusu
    
    await db.commit()
    await db.refresh(conta)
    
    return conta


# ========== ATUALIZAÇÃO DE STATUS (Automático para vencidas) ==========

@router.post("/atualizar-vencidas", response_model=dict)
async def atualizar_contas_vencidas(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Atualiza status de contas vencidas (A_RECEBER -> VENCIDO)"""
    
    hoje = date.today()
    
    query = select(ContaReceber).where(
        and_(
            ContaReceber.statcar == "A_RECEBER",
            ContaReceber.datven < hoje
        )
    )
    
    # Filtro de tenant
    if not current_user.issuper:
        query = query.where(
            and_(
                ContaReceber.codemp == current_user.codemp,
                ContaReceber.codfil == current_user.codfil
            )
        )
    
    result = await db.execute(query)
    contas_vencidas = result.scalars().all()
    
    count = 0
    for conta in contas_vencidas:
        conta.statcar = "VENCIDO"
        count += 1
    
    await db.commit()
    
    return {"message": f"{count} contas atualizadas para VENCIDO"}
